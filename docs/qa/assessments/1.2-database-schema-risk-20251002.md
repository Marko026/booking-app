# Risk Profile: Story 1.2 - Database Schema & Prisma Setup

Date: 2025-10-02
Reviewer: Quinn (Test Architect)

## Executive Summary

- Total Risks Identified: 8
- Critical Risks: 0
- High Risks: 1
- Medium Risks: 3
- Low Risks: 4
- Risk Score: 75/100 (Moderate-Low Risk)

## Critical Risks Requiring Immediate Attention

None identified. This is a foundation story with well-defined requirements and established patterns.

## High Risks

### 1. [DATA-001]: Data Migration Path Not Defined

**Score: 6 (High)**
**Probability**: Medium (2) - Schema changes are inevitable during development
**Impact**: High (3) - Breaking changes could cause data loss or require manual intervention

**Description**: While the story covers initial migration creation, it doesn't define a strategy for handling schema evolution, rollback procedures, or production data migration safety.

**Affected Components**:

- `prisma/schema.prisma`
- `prisma/migrations/`
- Production database

**Mitigation**:

- Document migration rollback procedure
- Implement migration testing in CI/CD
- Add migration dry-run validation before deployment
- Create backup strategy before any production migration
- Use Prisma's migration warnings and preview features

**Testing Requirements**:

- Test migration rollback scenarios
- Validate migration idempotency
- Test schema changes with existing data
- Integration tests with migration execution

**Residual Risk**: Low - With proper procedures and testing
**Owner**: dev
**Timeline**: Before production deployment (Story 1.6)

## Medium Risks

### 2. [PERF-001]: Missing Query Performance Baseline

**Score: 4 (Medium)**
**Probability**: Medium (2) - Performance issues often surface later
**Impact**: Medium (2) - Slow queries could degrade user experience

**Description**: While indexes are defined, there's no performance testing or query analysis to validate that the indexing strategy is optimal.

**Affected Components**:

- All database queries
- Booking availability checks
- Pricing rule lookups

**Mitigation**:

- Use Prisma's query logging in development
- Add query performance tests for critical paths
- Monitor query execution time
- Use EXPLAIN ANALYZE for complex queries
- Consider adding composite indexes based on actual query patterns

**Testing Requirements**:

- Performance benchmarks for key queries
- Load testing with realistic data volumes
- Query plan analysis

**Residual Risk**: Low - Can be addressed iteratively
**Owner**: dev
**Timeline**: During Story 2.1 (Availability Calendar)

### 3. [DATA-002]: Decimal Precision Not Specified

**Score: 4 (Medium)**
**Probability**: Medium (2) - Financial calculations are sensitive
**Impact**: Medium (2) - Rounding errors could cause pricing discrepancies

**Description**: Prisma Decimal type doesn't specify precision and scale for `basePricePerNight`, `totalPrice`, and `pricePerNight`. This could lead to inconsistent decimal handling across databases.

**Affected Components**:

- `Apartment.basePricePerNight`
- `Booking.totalPrice`
- `PricingRule.pricePerNight`

**Mitigation**:

- Specify Decimal precision: `@db.Decimal(10, 2)` for currency
- Document currency handling strategy
- Add validation for price ranges
- Use consistent rounding rules in calculations

**Testing Requirements**:

- Unit tests for decimal precision
- Test price calculation accuracy
- Validate database storage precision

**Residual Risk**: Very Low - Easy fix
**Owner**: dev
**Timeline**: During AC2, AC4, AC5 implementation

### 4. [TECH-001]: SQLite to PostgreSQL Migration Gap

**Score: 4 (Medium)**
**Probability**: High (2) - Guaranteed to happen in production
**Impact**: Medium (2) - Schema differences could cause deployment issues

**Description**: Story uses SQLite for development but production will use PostgreSQL (Supabase). Some Prisma features and SQL behaviors differ between these databases.

**Affected Components**:

- Schema migrations
- Date/time handling
- Array fields (`photos`)
- JSON fields (`amenities`)

**Mitigation**:

- Test schema generation against both databases
- Document known differences
- Use Prisma's database-agnostic features
- Consider using PostgreSQL in Docker for dev consistency
- Test migration against PostgreSQL before production deployment

**Testing Requirements**:

- Cross-database schema validation
- Migration testing on both databases
- Integration tests against PostgreSQL

**Residual Risk**: Low - Prisma handles most differences
**Owner**: dev
**Timeline**: Before Story 1.6 (Deployment)

## Low Risks

### 5. [DATA-003]: Missing Data Validation Constraints

**Score: 3 (Low)**
**Probability**: Low (1) - TypeScript provides some protection
**Impact**: High (3) - Invalid data could corrupt database

**Description**: Schema doesn't enforce business rules like `maxGuests > 0`, `endDate > startDate`, or valid email formats at the database level.

**Mitigation**:

- Add check constraints in future migrations
- Implement validation in API layer (Story 1.3)
- Use Zod schemas for runtime validation
- Document validation rules

**Testing Requirements**:

- Unit tests for validation logic
- Integration tests for constraint violations

**Residual Risk**: Very Low - Application-level validation sufficient
**Owner**: dev
**Timeline**: Story 1.3 (Authentication) and Story 2.3 (Booking Form)

### 6. [OPS-001]: Connection Pool Management Unclear

**Score: 3 (Low)**
**Probability**: Low (1) - Default settings usually sufficient
**Impact**: High (3) - Connection exhaustion could cause outages

**Description**: While singleton pattern is defined, connection pool configuration (max connections, timeout) is not specified.

**Mitigation**:

- Document Prisma connection pool defaults
- Add connection pool configuration for production
- Monitor database connection usage
- Implement connection health checks

**Testing Requirements**:

- Load tests for connection handling
- Connection leak detection tests

**Residual Risk**: Very Low - Prisma defaults are sensible
**Owner**: dev
**Timeline**: Story 1.6 (Deployment)

### 7. [SEC-001]: Guest Email Uniqueness Not Enforced

**Score: 2 (Low)**
**Probability**: Low (1) - Application logic will handle
**Impact**: Medium (2) - Duplicate guests could cause confusion

**Description**: Guest schema indexes email but doesn't enforce uniqueness, allowing duplicate guest records with the same email.

**Mitigation**:

- Add unique constraint to Guest.email
- Implement "find or create" logic in booking flow
- Document guest deduplication strategy

**Testing Requirements**:

- Integration tests for unique constraint
- Test guest lookup by email

**Residual Risk**: Minimal - Easy to add constraint
**Owner**: dev
**Timeline**: AC3 implementation

### 8. [TECH-002]: Seed Script Idempotency Not Guaranteed

**Score: 2 (Low)**
**Probability**: Medium (2) - Developers may run seed multiple times
**Impact**: Low (1) - Creates duplicate test data

**Description**: Seed script doesn't check for existing data before inserting, which could create duplicates if run multiple times.

**Mitigation**:

- Implement upsert logic in seed script
- Clear database before seeding
- Document seed script usage
- Add "reset database" npm script

**Testing Requirements**:

- Test seed script idempotency
- Validate seed data doesn't duplicate

**Residual Risk**: Minimal - Development only
**Owner**: dev
**Timeline**: AC9 implementation

## Risk Distribution

### By Category

- **Security (SEC)**: 1 risk (0 critical, 0 high, 0 medium, 1 low)
- **Performance (PERF)**: 1 risk (0 critical, 0 high, 1 medium, 0 low)
- **Data (DATA)**: 3 risks (0 critical, 1 high, 1 medium, 1 low)
- **Operational (OPS)**: 1 risk (0 critical, 0 high, 0 medium, 1 low)
- **Technical (TECH)**: 2 risks (0 critical, 0 high, 1 medium, 1 low)
- **Business (BUS)**: 0 risks

### By Component

- **Schema Definition**: 3 risks (DATA-002, DATA-003, SEC-001)
- **Migrations**: 2 risks (DATA-001, TECH-001)
- **Query Performance**: 1 risk (PERF-001)
- **Connection Management**: 1 risk (OPS-001)
- **Seed Scripts**: 1 risk (TECH-002)

## Detailed Risk Register

| Risk ID  | Category    | Description                     | Probability | Impact     | Score | Priority |
| -------- | ----------- | ------------------------------- | ----------- | ---------- | ----- | -------- |
| DATA-001 | Data        | Data migration path not defined | Medium (2)  | High (3)   | 6     | High     |
| PERF-001 | Performance | Missing query performance test  | Medium (2)  | Medium (2) | 4     | Medium   |
| DATA-002 | Data        | Decimal precision not specified | Medium (2)  | Medium (2) | 4     | Medium   |
| TECH-001 | Technical   | SQLite to PostgreSQL gap        | Medium (2)  | Medium (2) | 4     | Medium   |
| DATA-003 | Data        | Missing validation constraints  | Low (1)     | High (3)   | 3     | Low      |
| OPS-001  | Operational | Connection pool unclear         | Low (1)     | High (3)   | 3     | Low      |
| SEC-001  | Security    | Email uniqueness not enforced   | Low (1)     | Medium (2) | 2     | Low      |
| TECH-002 | Technical   | Seed script not idempotent      | Medium (2)  | Low (1)    | 2     | Low      |

## Risk-Based Testing Strategy

### Priority 1: High Risk Tests (DATA-001)

**Migration Testing**:

- Test forward migration execution
- Test migration rollback scenarios
- Validate migration with existing data
- Test migration idempotency (can run multiple times safely)
- Verify schema state after migration

**Test Scenarios**:

1. Fresh database migration succeeds
2. Migration rollback restores previous schema
3. Migration with existing data preserves data integrity
4. Re-running migration doesn't cause errors

### Priority 2: Medium Risk Tests (PERF-001, DATA-002, TECH-001)

**Performance Testing**:

- Benchmark booking availability queries
- Benchmark pricing rule lookups
- Test query performance with large datasets (1000+ bookings)

**Decimal Precision Testing**:

- Validate currency calculations with Decimal type
- Test rounding behavior across operations
- Verify database storage precision

**Cross-Database Testing**:

- Generate schema for both SQLite and PostgreSQL
- Compare migration outputs
- Test date/time handling differences
- Validate JSON and array field behavior

### Priority 3: Low Risk Tests (DATA-003, OPS-001, SEC-001, TECH-002)

**Validation Testing**:

- Test application-level validation rules
- Unit tests for business rule enforcement

**Connection Management**:

- Test connection pool under load
- Validate singleton pattern in development

**Seed Script Testing**:

- Test seed script idempotency
- Validate seed data structure

## Risk Acceptance Criteria

### Must Fix Before Production

- **DATA-001**: Document and test migration rollback procedure
- **DATA-002**: Specify decimal precision for all currency fields
- **TECH-001**: Validate schema against PostgreSQL

### Can Deploy with Mitigation

- **PERF-001**: Can monitor and optimize post-deployment
- **OPS-001**: Prisma defaults acceptable, monitor in production
- **DATA-003**: Application-layer validation sufficient initially

### Accepted Risks

- **SEC-001**: Can be added in later migration if needed
- **TECH-002**: Development-only concern, low impact

## Monitoring Requirements

Post-deployment monitoring for:

- **Migration Status**: Track all migrations applied, monitor for failures
- **Query Performance**: Log slow queries (>100ms), track P95/P99 latencies
- **Connection Pool**: Monitor active connections, connection wait times
- **Database Health**: Connection failures, transaction rollbacks
- **Data Integrity**: Orphaned records, constraint violations

## Risk Review Triggers

Review and update risk profile when:

- Schema changes significantly (new models or relationships)
- Performance issues reported in production
- Migration failures occur
- Database scaling requirements change
- Moving from SQLite to PostgreSQL (Story 1.6)

## Recommendations by Phase

### During Development (Story 1.2)

1. Add decimal precision to all currency fields
2. Enforce Guest.email uniqueness
3. Implement seed script with upsert logic
4. Document migration rollback procedure

### Before First Deployment (Story 1.6)

1. Test all migrations against PostgreSQL
2. Validate query performance with production data volumes
3. Configure connection pool for production environment
4. Set up database monitoring and alerting

### Post-Deployment

1. Monitor query performance metrics
2. Track migration execution in production
3. Review and optimize indexes based on actual usage
4. Consider adding database-level constraints for critical validations

## Integration with Quality Gates

Based on risk assessment:

- **Gate Decision**: CONCERNS (due to DATA-001 requiring attention)
- **Unmitigated High Risks**: 1 (DATA-001 - requires documentation and testing)
- **Recommended Actions**: Document migration strategy and add migration tests before Story 1.6

## Key Takeaways

1. **Overall Low Risk**: This is a well-designed database schema with industry best practices
2. **Main Concern**: Migration management and rollback procedures need documentation
3. **Quick Wins**: Adding decimal precision and email uniqueness are trivial fixes
4. **Future Planning**: Query performance monitoring should be implemented early
5. **Cross-Database**: PostgreSQL migration testing is critical before production deployment
